\section{overview}
To implement the usage contracts for Ruby we used three concepts of this programming language: meta-programming, reflexivity and usage of gems to parse the code.
To have a better understanding of the application's structure, there is the purpose of each files:
\begin{enumerate}
	\item[-] \verb+contractDsl.rb+: contains the DSL definition and methods to analyze structural regularities on the source code. 
	\item[-] \verb+mySexp.rb+: contains en extension of S-Expression definition generated by the parser (\verb+RubyParser+). It defines tools to ease the usage of s-expressions.
	\item[-] \verb+contracts/*.rb+: contains examples of contracts using the DSL.
	\item[-] \verb+examples/*.rb+: contains examples of source code to analyse.
	\end{enumerate}
To have more detailed informations about the implementation, this overview should be read together with the commented source code in \verb+contractDsl.rb+.
\subsection{Meta-programming}
To define an internal DSL implementing the usage contracts we used the meta-programming feature of Ruby. More precisely, we used the ability to pass blocks of code to a method and we evaluate them by using \verb+instance_eval()+. Each method implementing a structural condition returns a boolean value such that each evaluated block will return this value to the upper level. At the top level, the method \verb+require+ gets this value an inform the user whether the contract is respected or not. Moreover, the benefit of having methods only returning boolean value is that we can combine them using the \verb+and+ and \verb+or+ keywords of Ruby.



\subsection{Reflexivity}
The reflexive features of Ruby allowed us to implements structural conditions such as \verb+isImplemented?+ and \verb+isOverriden?+. To check whether a specific method is implemented in a specific class we used the reflexive \verb+instance_methods()+ function on the desired class.

To check whether a method is overridden or not we used \verb+ancestors()+ combined with \verb+instance_methods()+ function. Indeed, a function is considered as overridden when it is already defined in one of its ancestors class.


\subsection{The parser}
Unfortunately, Ruby does not allow the gathering of informations about function bodies. If we only had used the reflexive features or this language to implement the usage contracts, it wouldn't have been as expressive and useful as desired. To overcome this limitation we use a \emph{Gem} named \verb+RubyParser+ which allow us to obtain the AST of the classes and methods we analyze.

Using this parser allow us to implement functions such as \verb+calls?+, \verb+returns?+, \verb+assigns?+, \verb+doesSuperSend?+ and \verb+doesSelfSend?+ which respectively check if the liable method \emph{calls} a specific method, \emph{returns} a specific expression, \emph{assigns} a specific variable or does a \emph{super} or \emph{self} send.

In addition, the functions \verb+beginsWith+ and \verb+endsWith+ respectively check if the \emph{first} and \emph{last} statement of a method respect a particular condition (passed as a block).